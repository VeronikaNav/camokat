#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
using namespace std;
//класс товаров из которых создаётся заказ
class Product {
private:
    int _id;
    string _name;
    double _price;
public:
    Product(int id, const string& name, double price) : _id(id), _name(name), _price(price) {}
    Product() = default;
    ~Product() {};

    int getId() const { return _id; }
    string getName() const { return _name; }
    double getPrice() const { return _price; }
    // Операторы ввода и вывода для продукта
    friend istream& operator>>(istream& in, Product& p) {
        string q;
        in >> p._id;
        in>> p._name;
        in>> p._price;
        return in;
    }
    friend ostream& operator<<(ostream& out, const Product& p) {
        out  << p._id << " " << p._name << " " << p._price;
        return out;
    }
};
//функция считывания из файла
template <typename T>
void ReadFile(const string& filename, vector<T>& ar) {
    ifstream in(filename);
    if (!in.is_open())
        return;
    int n;
    in >> n;
    ar.resize(n);
    if (n != 0) {
        for (int i = 0;i < n;i++) {
            in >> ar[i];
        }
    }
    in.close();
}
//функция записи в файл
template <typename T>
void writefile(const string& filename, vector<T>& ar) {
    ofstream out(filename);
    if (!out.is_open())
        return;
    out << ar.size() << endl;
    for (const auto& i : ar) {
        out << i << endl;
    }
    out.close();
}
//функция показывающая все доступные товары
void showProduct() {
    vector<Product> products;
    ReadFile("Product.txt", products);
        cout << "\n=== list ===\n";
        for (const auto& product : products) {
            cout << "  id " << product.getId() << ":\n";
            cout << "  name:" << product.getName() << endl;
            cout << "  price:" << product.getPrice() <<"\n"<< endl;
            
        }
    
}
//функция добавления товаров
void addProduct() {
    vector<Product> products;
    ReadFile("Product.txt", products);
    Product newProduct;
    cout << "vvedite: id, name i price tovara" << endl;
    cin >> newProduct;
    products.push_back(newProduct);
    writefile("Product.txt", products);
    cout << "kaif!\n\n";
}
class Order {
private:
    int _id;
    int _x, _y;
    vector<Product>products;

public:
    Order(int id, int x, int y) : _id(id), _x(x), _y(y) {}
    Order() = default;
    ~Order() {}
    int getX() const { return _x; }
    int getY()const { return _y; }
    // Сеттеры
    void setId(int id) { _id = id; }
    void setX(int x) { _x = x; }
    void setY(int y) { _y = y; }
    // Перегрузка оператора ввода
    friend istream& operator>>(istream& in, Order& p) {
        size_t kp;
        in >> p._id;
        in >> p._x >> p._y;
        in>> kp;
        p.products.clear();
        p.products.resize(kp);
        for (size_t i = 0;i < kp;i++) {
            in >> p.products[i];
        }
        return in;
    }
    friend ostream& operator<<(ostream& out, const Order& p) {
        out << p._id << " " << p._x << " " << p._y << " " << p.products.size(); // Основные данные заказа
        // Затем продукты. Формат вывода каждого продукта должен быть совместим с Product::operator>>
        // Если Product::operator>> читает продукт и останавливается (например, на \n),
        // то после основных данных заказа нужен \n, и после каждого продукта \n.
        out << endl;
        for (const auto& product : p.products) {
            out << product << endl; // Предполагаем, что Product::operator<< пишет продукт и завершает строкой
        }
        return out;
    }
    void adProduct(const Product& product) {
        products.push_back(product);
    }
};
//функция добавления заказа на определённый склад
void addOrder() {
    int idd, x, y;
    vector<Order>orders;
    vector<Storage>stor;
    ReadFile("Order.txt", orders);
    int q;
    cout << "viberite sklad(id)" << endl;
    showStorage();
    cin >> q;
    ReadFile("Storage.txt", stor);
    auto it = find_if(stor.begin(), stor.end(), [q](const Storage& s) { return s.getId() == q; });

    if (it != stor.end()) {

        Order newOrder;
        cout << "Enter the Order ID: ";
        cin >> idd;
        newOrder.setId(idd);
        cout << "Enter the Order coordinates (x y): ";
        cin >> x >> y;
        newOrder.setX(x);
        newOrder.setY(y);
        showProduct();
        vector<Product>product;
        ReadFile("Product.txt", product);
        int id;
        while (1) {
            cout << "select a product from the list and enter its id(exit-0:) ";
            cin >> id;
            if (id == 0)
                break;
            for (const auto& i : product) {
                if (id == i.getId())
                    newOrder.adProduct(i);
            }
        }
        it->adQueue(newOrder); // Добавляем курьера в склад
        orders.push_back(newOrder);
        writefile("Order.txt", orders);
        cout << "The courier has been successfully added!" << endl;
        writefile("Storage.txt", stor);
    }
    else {
        cout << "Storage with ID " << q << " not found." << endl;
    }
}
//функция проверки наличия файла и создания его если его небыло до этого
void files(const string& filename) {
    int n = 0;
    ifstream in(filename);
    if (!in.is_open()) {
        ofstream out(filename);
        if (!out.is_open())
            return;
        out << n << endl;
        out.close();
    }
    else
    {
        in.close();
    }
}
//класс курьеров
class Curier {
private:
    int _id;
    int _x, _y;
    int _statex, _statey;
    int _speed;
    string _state;
    Order _ord;
    
public:
    Curier(int id, int x, int y,int statex,int statey,int speed,string state, Order ord) : _id(id), _x(x), _y(y),_statex(statex),_statey(statey),_speed(speed),_state(state), _ord(ord) {}
    Curier() = default;
    ~Curier() {}
    

    // Геттеры
    int getX() const { return _x; }
    int getY() const { return _y; }
    int getId() const { return _id; }

    int getXs() const { return _statex; }
    int getYs() const { return _statey; }
    std::string getState() const { return _state; }
    Order getOrd() const { return _ord; }
    int getSpeed() const { return _speed; }

    // Сеттеры
    void setId(int id) { _id = id; }
    void setX(int x) { _x = x; }
    void setY(int y) { _y = y; }
    void setSX(int statex) { _statex = statex; }
    void setSY(int statey) { _statey = statey; }
    void setSpeed(int speed) { _speed = speed; }
    void setState(const std::string& state) { _state = state; }
    void setOrd(const Order& ord) { _ord = ord; }
    friend istream& operator>>(istream& in, Curier& p) {
        in >> p._id;
        in >> p._x >> p._y;
        in>>p._statex >> p._statey;
        in >> p._speed;
        in >> p._state;
        in>> p._ord;
        return in;
    }
    friend ostream& operator<<(ostream & out, const Curier& p) {
            out << p._id << " " << p._x << " " << p._y<<" "<<p._statex<<" "<<p._statey<<" " << p._speed << " " << p._state << " " << p._ord;
            return out;
     }
    
};
//функция удаления курьера
void removeCurier() {
    cout << "print storage id" << endl;
    int id;
    cin >> id;
    vector<Storage>storages;
    ReadFile("Storage.txt", storages);
    for (auto& stor : storages) {
        if (id == stor.getId()) {
            cout << "print id curier" << endl;
            int idc;
            cin >> idc;
            vector<Curier>cu;
            cu = stor.getCur();
            auto it = std::remove_if(cu.begin(), cu.end(), [idc](const Curier& kur) {return kur.getId() == idc; });
            if (it != cu.end()) {
                cu.erase(it, cu.end()); // Удаляем найденных курьеров
                cout << "Curier with id " << idc << " removed." << endl;
            }
            else {
                cout << "Curier with id " << idc << " not found." << endl;
            }
            stor.setCur(cu);
           
        }
        else {
            cout << "Warehome with id " << id << " not found." << endl;
        }
    }
    writefile("Storage.txt", storages);

}
//функция добавления курьера на определённый склад
void addCurier() {
    int _id;
    int _x, _y;
    float _speed;
    vector<Storage>stor;
    vector<Curier>curi;
    int q;
    cout << "viberite sklad(id)" << endl;
    showStorage();
    cin >> q;      
    ReadFile("Storage.txt", stor);
    auto it = find_if(stor.begin(), stor.end(), [q](const Storage& s) { return s.getId() == q; });

    if (it != stor.end()) {
            Curier newCurier; // Создаем нового курьера
            cout << "Enter the courier's details:" << endl;
            cin >> _id;
            _x = it->getX();
            _y = it->getY();
            cin >> _speed;
            newCurier.setId(_id);
            newCurier.setX(_x);
            newCurier.setY(_y);
            newCurier.setSX(_x);
            newCurier.setSY(_y);
            newCurier.setSpeed(_speed);
            newCurier.setState("free");

            it->adCurier(newCurier); // Добавляем курьера в склад
            curi.push_back(newCurier); // Сохраняем курьера в общий список
            cout << "The courier has been successfully added!" << endl;
            writefile("Storage.txt", stor);
            
        }
        else {
            cout << "Склад с id " << q << " не найден." << endl;
        }
   
}


